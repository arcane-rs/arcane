//! Code generation related to [`Event`] and its aiding [`Event`] machinery.

#[cfg(all(doc, feature = "doc"))]
use arcane_core::es::{event, ConcreteEvent, Event, StaticEvent};

#[doc(inline)]
pub use arcane_codegen_shim::Event;

/// Concatenates the specified slices at `const` evaluation phase.
///
/// # Panics
///
/// If all the specified slices are empty.
#[macro_export]
macro_rules! const_concat_slices {
    ($($s:expr),* $(,)?) => {{
        const LEN: usize = 0 $(+ $s.len())*;
        &$crate::es::event::concat_slices::<_, LEN>(&[$($s),*])
    }};
}

/// Concatenates the specified slice of slices into an array of `LEN` size.
///
/// > **NOTE**: This is an inner implementation detail of the
/// >           [`const_concat_slices!`] macro, extracted into a separate
/// >           `const` function to reduce compilation times.
///
/// # Panics
///
/// - If all the specified slices are empty.
/// - If `LEN` size mismatches the total length of all the specified slices.
pub const fn concat_slices<T: Copy, const LEN: usize>(
    input: &[&[T]],
) -> [T; LEN] {
    let default_value = {
        let (mut i, mut total_len) = (0, 0);
        let mut first_elem = None;
        while i < input.len() {
            total_len += input[i].len();
            if matches!(first_elem, None) && total_len > 0 {
                first_elem = Some(input[i][0]);
            }
            i += 1;
        }
        // TODO: Use `assert_ne!()` here, once it's allowed in `const` context.
        #[allow(clippy::manual_assert)]
        if total_len != LEN {
            panic!("Actual slices lengths mismatches the specified `LEN` const")
        }
        let Some(val) = first_elem else {
            panic!("Specified `LEN` const cannot be zero")
        };
        val
    };

    let mut out = [default_value; LEN];
    let (mut i, mut n) = (0, 0);
    while i < input.len() {
        let mut j = 0;
        while j < input[i].len() {
            out[n] = input[i][j];
            n += 1;
            j += 1;
        }
        i += 1;
    }
    out
}

/// Compile time reflection of an [`Event`] (either a single or multiple
/// [`StaticEvent`]s or [`ConcreteEvent`]s), used by code generation to generate
/// additional `const` assertions of [`Event`] properties.
///
/// > **NOTE**: Implementations of this trait are automatically generated by
/// >           `#[derive(Event)]` macro, and don't represent a part of public
/// >           API.
pub trait Reflect {
    /// Meta information of this [`Event`], containing its all combinations of:
    /// - Unique Rust type identifier.
    /// - [`StaticEvent::NAME`].
    /// - Stringified [`ConcreteEvent::REVISION`].
    const META: &'static [(&'static str, &'static str, &'static str)];
}

/// Checks whether all the combinations of [`StaticEvent::NAME`] and
/// [`ConcreteEvent::REVISION`] in [`Reflect::META`] correspond to different
/// Rust types.
///
/// Correctness is checked by asserting this function at compile time in `const`
/// context.
#[must_use]
pub const fn has_different_types_with_same_name_and_revision<E: Reflect>(
) -> bool {
    let events = <E as Reflect>::META;

    let mut outer = 0;
    while outer < events.len() {
        let mut inner = outer + 1;
        while inner < events.len() {
            let (inner_ty, inner_name, inner_rev) = events[inner];
            let (outer_ty, outer_name, outer_rev) = events[outer];

            if !str_eq(inner_ty, outer_ty)
                && str_eq(inner_name, outer_name)
                && str_eq(inner_rev, outer_rev)
            {
                return true;
            }
            inner += 1;
        }
        outer += 1;
    }

    false
}

/// Compares strings in `const` context.
///
/// As there is no `const impl Trait` and `l == r` calls [`Eq`], we have to
/// write custom comparison function.
///
/// [`Eq`]: trait@Eq
// TODO: Remove once `Eq` trait is allowed in `const` context.
const fn str_eq(l: &str, r: &str) -> bool {
    if l.len() != r.len() {
        return false;
    }

    let (l, r) = (l.as_bytes(), r.as_bytes());
    let mut i = 0;
    while i < l.len() {
        if l[i] != r[i] {
            return false;
        }
        i += 1;
    }

    true
}

#[cfg(test)]
mod has_different_types_with_same_name_and_revision_spec {
    use super::{has_different_types_with_same_name_and_revision, Reflect};

    #[test]
    fn no_when_all_events_are_unique() {
        struct Ev;

        impl Reflect for Ev {
            const META: &'static [(
                &'static str,
                &'static str,
                &'static str,
            )] = &[("A", "a", "1"), ("B", "b", "2"), ("C", "c", "3")];
        }

        assert!(!has_different_types_with_same_name_and_revision::<Ev>());
    }

    #[test]
    fn no_when_has_same_types_with_same_name_and_revision() {
        struct Ev;

        impl Reflect for Ev {
            const META: &'static [(
                &'static str,
                &'static str,
                &'static str,
            )] = &[("A", "a", "1"), ("A", "a", "1"), ("A", "b", "1")];
        }

        assert!(!has_different_types_with_same_name_and_revision::<Ev>());
    }

    #[test]
    fn no_when_has_same_types_with_same_name_and_empty_revision() {
        struct Ev;

        impl Reflect for Ev {
            const META: &'static [(
                &'static str,
                &'static str,
                &'static str,
            )] = &[("A", "a", ""), ("A", "a", ""), ("A", "b", "")];
        }

        assert!(!has_different_types_with_same_name_and_revision::<Ev>());
    }

    #[test]
    fn yes_when_has_different_types_and_same_name_and_revision() {
        struct Ev;

        impl Reflect for Ev {
            const META: &'static [(
                &'static str,
                &'static str,
                &'static str,
            )] = &[("A", "a", "1"), ("B", "a", "1"), ("A", "b", "1")];
        }

        assert!(has_different_types_with_same_name_and_revision::<Ev>());
    }

    #[test]
    fn yes_when_one_type_with_empty_revision_and_same_name() {
        struct Ev;

        impl Reflect for Ev {
            const META: &'static [(
                &'static str,
                &'static str,
                &'static str,
            )] = &[("A", "a", "1"), ("B", "a", ""), ("A", "b", "1")];
        }

        assert!(!has_different_types_with_same_name_and_revision::<Ev>());
    }

    #[test]
    fn yes_when_has_different_types_with_same_names_without_revisions() {
        struct Ev;

        impl Reflect for Ev {
            const META: &'static [(
                &'static str,
                &'static str,
                &'static str,
            )] = &[("A", "a", ""), ("B", "a", ""), ("A", "b", "1")];
        }

        assert!(has_different_types_with_same_name_and_revision::<Ev>());
    }
}
